#eventListen
    //网络编程基础步骤
        //创建socket
        //如果它的条件返回错误，则终止程序执行 

    //TCP连接断开的时候调用closesocket函数，有优雅的断开和强制断开两种方式
    
    //优雅关闭连接
        //TODO:如果判定为?
            //底层会将未发送完的数据发送完成后再释放资源，也就是优雅的退出
        //TODO:如果判定为?
            //这种方式下，在调用closesocket的时候不会立刻返回，内核会延迟一段时间，这个时间就由l_linger得值来决定。
            //如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，closesocket会返回正确，socket描述符优雅性退出。
            //否则，closesocket会直接返回 错误值，未发送数据丢失，socket描述符被强制性退出。需要注意的时，如果socket描述符被设置为非堵塞型，则closesocket会直接返回值。

    //初始化地址并绑定到address,后面便可以绑定到socket中 

    //允许重用本地地址和端口

    //传统绑定步骤
        //错误判断

    //传统监听步骤
        //错误判断

    utils.init(TIMESLOT);

    //epoll创建内核事件表

    //将lfd上树

    //创建管道套接字
        //错误判断
    //设置管道写端为非阻塞，为什么写端要非阻塞？
    //send是将信息发送给套接字缓冲区，如果缓冲区满了，则会阻塞，
    //这时候会进一步增加信号处理函数的执行时间，为此，将其修改为非阻塞。

    //设置管道读端为ET非阻塞 统一事件源

    //传递给主循环的信号值，这里只关注SIGALRM和SIGTERM
    //每隔TIMESLOT时间触发SIGALRM信号

    //工具类,信号和描述符基础操作
    Utils::u_pipefd = m_pipefd;
    Utils::u_epollfd = m_epollfd;


eventloop
    //不断循环(这个函数终结,服务器也终结)
        //监测发生事件的文件描述符
            //判断错误

        //轮询有事件产生的文件描述符 
            //处理新到的客户连接
            //服务器端关闭连接，移除对应的定时器

            //处理信号
                //管道读端对应文件描述符发生读事件
                //因为统一了事件源，信号处理当成读事件来处理
                //怎么统一？就是信号回调函数哪里不立即处理而是写到：pipe的写端

            //处理客户连接上接收到的数据

            //每处理完一组,就刷新定时器


dealclientdata
