首先粗略过一遍,然后复习一个文档的计算机网络





//1 看着文档看完他,每个模块都看,并且做笔记

//2 不看具体代码,把整个再串起来做流程图什么的
if(!zhihu串起来) 
{
    加上它本身的文档去看
}


//3 把笔记整理成人家博客的差不多






# eventListen
    //网络编程基础步骤
        //创建socket
        //如果它的条件返回错误，则终止程序执行 

    //TCP连接断开的时候调用closesocket函数，有优雅的断开和强制断开两种方式
    
    //优雅关闭连接
        //TODO:如果判定为?
            //底层会将未发送完的数据发送完成后再释放资源，也就是优雅的退出
        //TODO:如果判定为?
            //这种方式下，在调用closesocket的时候不会立刻返回，内核会延迟一段时间，这个时间就由l_linger得值来决定。
            //如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，closesocket会返回正确，socket描述符优雅性退出。
            //否则，closesocket会直接返回 错误值，未发送数据丢失，socket描述符被强制性退出。需要注意的时，如果socket描述符被设置为非堵塞型，则closesocket会直接返回值。

    //初始化地址并绑定到address,后面便可以绑定到socket中 

    //允许重用本地地址和端口

    //传统绑定步骤
        //错误判断

    //传统监听步骤
        //错误判断

    utils.init(TIMESLOT);

    //epoll创建内核事件表

    //将lfd上树

    //创建管道套接字
        //错误判断
    //设置管道写端为非阻塞，为什么写端要非阻塞？
    //send是将信息发送给套接字缓冲区，如果缓冲区满了，则会阻塞，
    //这时候会进一步增加信号处理函数的执行时间，为此，将其修改为非阻塞。

    //设置管道读端为ET非阻塞 统一事件源

    //传递给主循环的信号值，这里只关注SIGALRM和SIGTERM
    //每隔TIMESLOT时间触发SIGALRM信号

    //工具类,信号和描述符基础操作
    Utils::u_pipefd = m_pipefd;
    Utils::u_epollfd = m_epollfd;


# eventloop
    //不断循环(这个函数终结,服务器也终结)
        //监测发生事件的文件描述符
            //判断错误

        //轮询有事件产生的文件描述符 
            //处理新到的客户连接
            //服务器端关闭连接，移除对应的定时器

            //处理信号
                //管道读端对应文件描述符发生读事件
                //因为统一了事件源，信号处理当成读事件来处理
                //怎么统一？就是信号回调函数哪里不立即处理而是写到：pipe的写端

            //处理客户连接上接收到的数据

            //每处理完一组,就刷新定时器


# dealclientdata


# dealwithread


# dealwithwirte

# dealwithsignal 
    //从管道读端读出信号值，成功返回字节数，失败返回-1
        //正常情况下，这里的ret返回值总是1，只有14和15两个ASCII码对应的字符
        //TODO:返回0也是要false?莫非是没有信号?

    //处理信号值对应的逻辑
        //进行相应的操作


# timer
    //初始化client_data数据

    //创建定时器，设置回调函数和超时时间，绑定用户数据，将定时器添加到链表中



# run
//回调函数会调用这个函数工作
    //工作线程就是不断地等任务队列有新任务，然后就加锁取任务->取到任务解锁->执行任务
        //信号量等待
        //被唤醒后先加互斥锁

        //从请求队列中取出第一个任务
        //将任务从请求队列删除
        //preactor reactor各自地处理

