首先粗略过一遍,然后复习一个文档的计算机网络





//1 看着文档看完他,每个模块都看,并且做笔记

//2 不看具体代码,把整个再串起来做流程图什么的
if(!zhihu串起来) 
{
    加上它本身的文档去看
}


//3 把笔记整理成人家博客的差不多






# eventListen
    //网络编程基础步骤
        //创建socket
        //如果它的条件返回错误，则终止程序执行 

    //TCP连接断开的时候调用closesocket函数，有优雅的断开和强制断开两种方式
    
    //优雅关闭连接
        //TODO:如果判定为?
            //底层会将未发送完的数据发送完成后再释放资源，也就是优雅的退出
        //TODO:如果判定为?
            //这种方式下，在调用closesocket的时候不会立刻返回，内核会延迟一段时间，这个时间就由l_linger得值来决定。
            //如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，closesocket会返回正确，socket描述符优雅性退出。
            //否则，closesocket会直接返回 错误值，未发送数据丢失，socket描述符被强制性退出。需要注意的时，如果socket描述符被设置为非堵塞型，则closesocket会直接返回值。

    //初始化地址并绑定到address,后面便可以绑定到socket中 

    //允许重用本地地址和端口

    //传统绑定步骤
        //错误判断

    //传统监听步骤
        //错误判断

    utils.init(TIMESLOT);

    //epoll创建内核事件表

    //将lfd上树

    //创建管道套接字
        //错误判断
    //设置管道写端为非阻塞，为什么写端要非阻塞？
    //send是将信息发送给套接字缓冲区，如果缓冲区满了，则会阻塞，
    //这时候会进一步增加信号处理函数的执行时间，为此，将其修改为非阻塞。

    //设置管道读端为ET非阻塞 统一事件源

    //传递给主循环的信号值，这里只关注SIGALRM和SIGTERM
    //每隔TIMESLOT时间触发SIGALRM信号

    //工具类,信号和描述符基础操作
    Utils::u_pipefd = m_pipefd;
    Utils::u_epollfd = m_epollfd;


# eventloop
    //不断循环(这个函数终结,服务器也终结)
        //监测发生事件的文件描述符
            //判断错误

        //轮询有事件产生的文件描述符 
            //处理新到的客户连接
            //服务器端关闭连接，移除对应的定时器

            //处理信号
                //管道读端对应文件描述符发生读事件
                //因为统一了事件源，信号处理当成读事件来处理
                //怎么统一？就是信号回调函数哪里不立即处理而是写到：pipe的写端

            //处理客户连接上接收到的数据

            //每处理完一组,就刷新定时器


# dealclientdata


# dealwithread


# dealwithwirte

# dealwithsignal 
    //从管道读端读出信号值，成功返回字节数，失败返回-1
        //正常情况下，这里的ret返回值总是1，只有14和15两个ASCII码对应的字符
        //TODO:返回0也是要false?莫非是没有信号?

    //处理信号值对应的逻辑
        //进行相应的操作


# timer
    //初始化client_data数据

    //创建定时器，设置回调函数和超时时间，绑定用户数据，将定时器添加到链表中



# run
//回调函数会调用这个函数工作
    //工作线程就是不断地等任务队列有新任务，然后就加锁取任务->取到任务解锁->执行任务
        //信号量等待
        //被唤醒后先加互斥锁

        //从请求队列中取出第一个任务
        //将任务从请求队列删除
        //preactor reactor各自地处理



# process
    //NO_REQUEST，表示请求不完整，需要继续接收请求数据
        //注册并监听读事件
    //调用process_write完成报文响应
        //TODO:如果?关闭连接
    //注册并监听写事件


# process_read
//通过while循环 封装主状态机 对每一行进行循环处理
//此时 从状态机已经修改完毕 主状态机可以取出完整的行进行解析
    //初始化从状态机的状态

    //判断条件，这里就是从状态机驱动主状态机 
        //m_start_line 是每一个数据行在m_read_buf中的起始位置
        //m_checked_idx 表示从状态机在m_read_buf中的读取位置

        //三种状态转换逻辑
            //解析请求行
            //解析请求头
                //作为get请求 则需要跳转到报文响应函数
            //解析消息体 
                //对于post请求 跳转到报文响应函数
            //更新 跳出循环 代表解析完了消息体


# prase_request_line
//解析http请求行，获得请求方法，目标url及http版本号
    //请求行中最先含有空格和\t任一字符的位置并返回
    //没有目标字符 则代表报文格式有问题
    //用于将前面的数据取出

    //取出数据 确定请求方式
	//m_url此时跳过了第一个空格或者\t字符，但是后面还可能存在
    //不断后移找到请求资源的第一个字符

    //判断http的版本号

    //目前社长项目仅支持http1.1

    //对请求资源的前七个字符进行判断
    //对某些带有http://的报文进行单独处理

    //https的情况 
    //不符合规则的报文

    //当url为/时，显示欢迎界面
    //主状态机状态转移
